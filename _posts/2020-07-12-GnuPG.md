---
title: GnuPG配置用于SSH的RSA密钥
tag: ssh gpg pgp
---

为了避免每次远程ssh连接的时候输入用户名和密码，我们会用ssh-keygen生成的RSA公私密钥对来自动化ssh登陆认证的过程。GnuPG可以生成和管理密钥，于是我就想把用于ssh连接的RSA密钥也托管给它。这样以来，所有日常工作用到的密钥都由GnuPG集中统一管理，同时也方便备份。这篇文章完整介绍如何用GnuPG配置一个可以用于ssh登陆认证的RSA密钥，以及配置过程中需要注意的那些坑。

首先，当我们讨论PGP密钥的时候，很多时候指的是一组密钥，而不是一个密钥。PGP密钥分为主密钥和子密钥，通常的配置方式是一个主密钥外加多个子密钥，每个子密钥被分配不同功能，且都用主密钥签过名。这样做的好处是可以最大程度保护主密钥，因为几乎所有日常操作都通过子密钥完成，主密钥的私钥可以离线保存。另外如果某个子密钥的安全性受到破坏的时候，我们可以很方便地用主密钥撤销子密钥，同时主密钥的信任度不受影响。关于PGP子密钥，非常推荐花时间读下[Using OpenPGP subkeys in Debian development](https://wiki.debian.org/Subkeys)这篇文章，里面介绍了子密钥概念以及配置PGP密钥的最佳实践。

我的开发环境是MacOS 10.15.5 + gpg (GnuPG) 2.2.21，配置开始之前我们假设还没有任何PGP密钥。

我们可以简单运行`gpg --gen-key`来生成一组新密钥，gpg会默认生成一个开启了Sign和Certify功能的主密钥以及一个Encrypt功能的子密钥（这里说的“一个”指一个公私密钥对）。为了了解所有细节，我们使用专家模式手动配置所有参数。

1）先建一个只有Certify功能的主密钥。这里需要注意Certify和Sign的区别，Certify指的是给其它密钥签名，其它密钥可以是自己创建的子密钥或者别人的主密钥；Sign指的是给数据签名。

```shell
$ gpg --expert --full-gen-key

gpg (GnuPG) 2.2.21; Copyright (C) 2020 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Please select what kind of key you want:
   (1) RSA and RSA (default)
   (2) DSA and Elgamal
   (3) DSA (sign only)
   (4) RSA (sign only)
   (7) DSA (set your own capabilities)
   (8) RSA (set your own capabilities)
   (9) ECC and ECC
  (10) ECC (sign only)
  (11) ECC (set your own capabilities)
  (13) Existing key
  (14) Existing key from card

Your selection? 8

Possible actions for a RSA key: Sign Certify Encrypt Authenticate
Current allowed actions: Sign Certify Encrypt

   (S) Toggle the sign capability
   (E) Toggle the encrypt capability
   (A) Toggle the authenticate capability
   (Q) Finished

Your selection? s

Possible actions for a RSA key: Sign Certify Encrypt Authenticate
Current allowed actions: Certify Encrypt

   (S) Toggle the sign capability
   (E) Toggle the encrypt capability
   (A) Toggle the authenticate capability
   (Q) Finished

Your selection? e

Possible actions for a RSA key: Sign Certify Encrypt Authenticate
Current allowed actions: Certify

   (S) Toggle the sign capability
   (E) Toggle the encrypt capability
   (A) Toggle the authenticate capability
   (Q) Finished

Your selection? q
RSA keys may be between 1024 and 4096 bits long.
What keysize do you want? (2048) 4096
Requested keysize is 4096 bits
Please specify how long the key should be valid.
         0 = key does not expire
      <n>  = key expires in n days
      <n>w = key expires in n weeks
      <n>m = key expires in n months
      <n>y = key expires in n years
Key is valid for? (0) 0
Key does not expire at all
Is this correct? (y/N) y

GnuPG needs to construct a user ID to identify your key.

Real name: [your name]
Email address: [your email]
Comment:

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O
```

gpg会自动在~/.gnupg目录下为我们生成撤销证书，可以用于撤销主密钥。

2）用刚才创建的主密钥生成一个只有Authenticate功能的子密钥

```shell
$ gpg --list-keys --keyid-format long                                                                                        
/Users/xxxxxxxxxx/.gnupg/pubring.kbx
------------------------------------
pub   rsa4096/0291021E5F56BD92 2020-07-12 [C]
      B782E151823E6A19A756C55A0291021E5F56BD92
uid                 [ultimate] yyyyyyyyyy

$ gpg --expert --edit-key 0291021E5F56BD92
gpg (GnuPG) 2.2.21; Copyright (C) 2020 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Secret key is available.

sec  rsa4096/0291021E5F56BD92
     created: 2020-07-12  expires: never       usage: C
     trust: ultimate      validity: ultimate
[ultimate] (1). yyyyyyyyyy

gpg> addkey
Please select what kind of key you want:
   (3) DSA (sign only)
   (4) RSA (sign only)
   (5) Elgamal (encrypt only)
   (6) RSA (encrypt only)
   (7) DSA (set your own capabilities)
   (8) RSA (set your own capabilities)
  (10) ECC (sign only)
  (11) ECC (set your own capabilities)
  (12) ECC (encrypt only)
  (13) Existing key
  (14) Existing key from card
Your selection? 8

Possible actions for a RSA key: Sign Encrypt Authenticate
Current allowed actions: Sign Encrypt

   (S) Toggle the sign capability
   (E) Toggle the encrypt capability
   (A) Toggle the authenticate capability
   (Q) Finished

Your selection? s

Possible actions for a RSA key: Sign Encrypt Authenticate
Current allowed actions: Encrypt

   (S) Toggle the sign capability
   (E) Toggle the encrypt capability
   (A) Toggle the authenticate capability
   (Q) Finished

Your selection? e

Possible actions for a RSA key: Sign Encrypt Authenticate
Current allowed actions:

   (S) Toggle the sign capability
   (E) Toggle the encrypt capability
   (A) Toggle the authenticate capability
   (Q) Finished

Your selection? a

Possible actions for a RSA key: Sign Encrypt Authenticate
Current allowed actions: Authenticate

   (S) Toggle the sign capability
   (E) Toggle the encrypt capability
   (A) Toggle the authenticate capability
   (Q) Finished

Your selection? q
RSA keys may be between 1024 and 4096 bits long.
What keysize do you want? (2048) 4096
Requested keysize is 4096 bits
Please specify how long the key should be valid.
         0 = key does not expire
      <n>  = key expires in n days
      <n>w = key expires in n weeks
      <n>m = key expires in n months
      <n>y = key expires in n years
Key is valid for? (0) 0
Key does not expire at all
Is this correct? (y/N) y
Really create? (y/N) y

gpg> save
```

编辑密钥的时候需要提供主密钥的id，id可以通过运行`gpg --list-keys --keyid-format long`找到。这里有几个关于id的概念：short id，long id，fingerprint，keygrip。[Stackflow上的最高票回答](https://security.stackexchange.com/questions/84280/short-openpgp-key-ids-are-insecure-how-to-configure-gnupg-to-use-long-key-ids-i)详细解释了前三者的区别，这里补充一下keygrip，之后配置的时候需要用到。keygrip可以理解成某个密钥的内部id，比如gpg-agent就是通过keygrip来唯一标识密钥的。但是在运行gpg命令的时候，我们只会用到密钥的外部id（short id，long id或者keygrip）。默认情况下keygrip是不显示的，需要用`--with-keygrip`来开启。

3）为gpg-agent开启ssh

```shell
$ echo 'enable-ssh-support' >> ~/.gnupg/gpg-agent.conf
```

4) 让gpg-agent介入ssh认证

```shell
$ echo 'export SSH_AUTH_SOCK=$(gpgconf --list-dirs agent-ssh-socket)' >> ~/.bashrc
```

这样gpg-agent可以通过socket和ssh-agent沟通。

5）配置需要使用的RSA密钥

```shell
$ gpg --list-secret-keys --with-keygrip
/Users/xxxxxxxxx/.gnupg/pubring.kbx
------------------------------------
sec   rsa4096 2020-07-12 [C]
      B782E151823E6A19A756C55A0291021E5F56BD92
      Keygrip = AC85B97781F550C9EB3C124F81A50FAD8BEDE215
uid           [ultimate] yyyyyyyyyy
ssb   rsa4096 2020-07-12 [A]
      Keygrip = A3D71EEA4B5297F4D066AFAAD0AF4A61D6850C9A

$ echo 'A3D71EEA4B5297F4D066AFAAD0AF4A61D6850C9A' > ~/.gnupg/sshcontrol
```

将刚才生成的用来Authenticate的私钥的keygrip写入sshcontrol文件，这样不用每次都手动去指定密钥id。注意这里写入sshcontrol的是密钥的keygrip而不是fingerprint。

6）重启gpg-agent

```shell
$ gpgconf --kill gpg-agent
$ gpg-agent --daemon
```

到此GnuPG部分的配置就完成了。

7）远端配置公钥

上面所有步骤完成后运行`ssh-add -L`可以看到所使用的RSA公钥，但是这个公钥不能直接复制粘贴到远端的authorized_keys中。这里我们手动从GnuPG中导出符合ssh格式的公钥。

```shell
$ gpg --list-keys --keyid-format long
/Users/xxxxxxxxx/.gnupg/pubring.kbx
------------------------------------
pub   rsa4096/0291021E5F56BD92 2020-07-12 [C]
      B782E151823E6A19A756C55A0291021E5F56BD92
uid                 [ultimate] yyyyyyyyyy
sub   rsa4096/54FD729941AC0B0A 2020-07-12 [A]

$ gpg --export-ssh-key 54FD729941AC0B0A | ssh -i ~/.ssh/id_rsa username@host '>> ~/.ssh/authorized_keys'
```

其中54FD729941AC0B0A是刚才生成的具有Authenticate功能的子密钥的long id。

大功告成，以后ssh连接远端服务器的时候会透明地使用GnuPG管理的私钥，测试没问题的话可以放心把原来ssh-keygen生成的密钥对删除。

-----

如果只对如何用GnuPG配置用于ssh连接的密钥对感兴趣，可以忽略本文之后部分。下面是关于如何管理和使用密钥的最佳实践。

我们之前只创建了用于Authenticate的子密钥，实际使用中还需要另外两个子密钥，分别用于Encrypt和Sign。具体创建过程类似上文中的第二步，在此不再赘述。最终的keyring包括一个用于Certify的主密钥和三个分管Authenticate、Encrypt和Sign的子密钥。keyring配置完成后，我们分别导出所有私钥和公钥作为备份离线存储。

```shell
$ gpg --export-secret-keys --armor 0291021E5F56BD92 > key.ssb

$ gpg --export --armor 0291021E5F56BD92 > key.sub
```

以后万一需要恢复的时候运行`gpg --import keyfile`就可以重新导入。
